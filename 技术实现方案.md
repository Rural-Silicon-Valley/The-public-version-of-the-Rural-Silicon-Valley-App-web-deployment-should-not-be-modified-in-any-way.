# åŠŸèƒ½å¼€å‘æŠ€æœ¯æ–¹æ¡ˆæ–‡æ¡£

## è¯¦ç»†å®ç°æŒ‡å—

### 1. ä»»åŠ¡ä¼˜å…ˆçº§å®ç°ä»£ç 

#### ä¿®æ”¹ç±»å‹å®šä¹‰

```typescript
// src/types/index.ts
export type TaskPriority = 'high' | 'medium' | 'low' | 'defer';

export interface Task {
  id: string;
  title: string;
  description: string;
  assignedTo: string[];
  createdBy: string;
  createdAt: Date;
  dueDate: Date;
  priority: TaskPriority; // æ–°å¢å­—æ®µ
  priorityColor: string;   // æ–°å¢å­—æ®µ
  status: 'pending' | 'completed';
}
```

#### ä¼˜å…ˆçº§é…ç½®

```typescript
// src/utils/priority.ts
import { Star, StarBorder, StarHalf, StarOutline } from '@mui/icons-material';

export const PRIORITY_CONFIG = {
  high: { label: 'ç´§æ€¥é‡è¦', color: '#f44336', icon: Star },
  medium: { label: 'é‡è¦ä¸ç´§æ€¥', color: '#ff9800', icon: StarHalf },
  low: { label: 'æ™®é€šä»»åŠ¡', color: '#4caf50', icon: StarBorder },
  defer: { label: 'å¯å»¶æœŸ', color: '#9e9e9e', icon: StarOutline }
};

export const getPriorityConfig = (priority: TaskPriority) => PRIORITY_CONFIG[priority];
```

#### ä¼˜å…ˆçº§é€‰æ‹©ç»„ä»¶

```typescript
// src/components/PrioritySelector.tsx
import React from 'react';
import { FormControl, InputLabel, Select, MenuItem, Chip, Box } from '@mui/material';
import { TaskPriority } from '../types';
import { PRIORITY_CONFIG } from '../utils/priority';

interface PrioritySelectorProps {
  value: TaskPriority;
  onChange: (priority: TaskPriority) => void;
}

export const PrioritySelector: React.FC<PrioritySelectorProps> = ({ value, onChange }) => {
  return (
    <FormControl fullWidth>
      <InputLabel>ä»»åŠ¡ä¼˜å…ˆçº§</InputLabel>
      <Select value={value} onChange={(e) => onChange(e.target.value as TaskPriority)}>
        {Object.entries(PRIORITY_CONFIG).map(([key, config]) => {
          const IconComponent = config.icon;
          return (
            <MenuItem key={key} value={key}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                <IconComponent sx={{ color: config.color }} />
                <span>{config.label}</span>
              </Box>
            </MenuItem>
          );
        })}
      </Select>
    </FormControl>
  );
};
```

### 2. ä»»åŠ¡çŠ¶æ€å¢å¼ºå®ç°

#### æ‰©å±•çŠ¶æ€ç±»å‹

```typescript
// src/types/index.ts
export type TaskStatus = 'pending' | 'in_progress' | 'paused' | 'completed' | 'overdue' | 'need_help';

export interface TaskStatusHistory {
  status: TaskStatus;
  timestamp: Date;
  updatedBy: string;
  comment?: string;
}

export interface Task {
  // ç°æœ‰å­—æ®µ...
  status: TaskStatus;
  statusUpdateTime: Date;
  statusHistory: TaskStatusHistory[];
}
```

#### çŠ¶æ€é…ç½®å’Œå·¥å…·å‡½æ•°

```typescript
// src/utils/taskStatus.ts
import { 
  Schedule, 
  PlayArrow, 
  Pause, 
  CheckCircle, 
  Warning, 
  Help 
} from '@mui/icons-material';

export const TASK_STATUS_CONFIG = {
  pending: { label: 'æœªå¼€å§‹', color: '#9e9e9e', icon: Schedule },
  in_progress: { label: 'è¿›è¡Œä¸­', color: '#2196f3', icon: PlayArrow },
  paused: { label: 'æš‚åœ', color: '#ff9800', icon: Pause },
  completed: { label: 'å·²å®Œæˆ', color: '#4caf50', icon: 'âœ…' },
  overdue: { label: 'é€¾æœŸ', color: '#f44336', icon: 'âš ï¸' },
  need_help: { label: 'éœ€è¦å¸®åŠ©', color: '#9c27b0', icon: 'ğŸ†˜' }
};

export const getStatusConfig = (status: TaskStatus) => TASK_STATUS_CONFIG[status];

export const isTaskOverdue = (task: Task): boolean => {
  return new Date() > new Date(task.dueDate) && task.status !== 'completed';
};
```

### 3. è¯„è®ºç³»ç»Ÿå®ç°

#### è¯„è®ºæ•°æ®ç±»å‹

```typescript
// src/types/index.ts
export interface TaskComment {
  id: string;
  taskId: string;
  userId: string;
  userName: string;
  userAvatar: string;
  content: string;
  timestamp: Date;
  parentCommentId?: string;
  attachments?: string[];
}
```

#### è¯„è®ºç»„ä»¶

```typescript
// src/components/TaskComments.tsx
import React, { useState } from 'react';
import { 
  Box, TextField, Button, List, ListItem, 
  Avatar, Typography, Paper, Divider 
} from '@mui/material';
import { TaskComment } from '../types';

interface TaskCommentsProps {
  taskId: string;
  comments: TaskComment[];
  onAddComment: (content: string) => void;
}

export const TaskComments: React.FC<TaskCommentsProps> = ({ 
  taskId, comments, onAddComment 
}) => {
  const [newComment, setNewComment] = useState('');

  const handleSubmit = () => {
    if (newComment.trim()) {
      onAddComment(newComment);
      setNewComment('');
    }
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        è¯„è®º ({comments.length})
      </Typography>
      
      {/* è¯„è®ºåˆ—è¡¨ */}
      <List>
        {comments.map((comment) => (
          <ListItem key={comment.id} alignItems="flex-start">
            <Paper sx={{ width: '100%', p: 2, mb: 1 }}>
              <Box display="flex" alignItems="center" mb={1}>
                <Avatar src={comment.userAvatar} sx={{ width: 32, height: 32, mr: 1 }}>
                  {comment.userName[0]}
                </Avatar>
                <Typography variant="subtitle2">{comment.userName}</Typography>
                <Typography variant="caption" color="text.secondary" ml="auto">
                  {new Date(comment.timestamp).toLocaleString()}
                </Typography>
              </Box>
              <Typography variant="body2">{comment.content}</Typography>
            </Paper>
          </ListItem>
        ))}
      </List>

      <Divider sx={{ my: 2 }} />

      {/* æ·»åŠ è¯„è®º */}
      <Box display="flex" gap={1}>
        <TextField
          fullWidth
          multiline
          rows={2}
          placeholder="æ·»åŠ è¯„è®º..."
          value={newComment}
          onChange={(e) => setNewComment(e.target.value)}
        />
        <Button variant="contained" onClick={handleSubmit}>
          å‘å¸ƒ
        </Button>
      </Box>
    </Box>
  );
};
```

### 4. å·¥ä½œæ—¶é—´è®°å½•å®ç°

#### æ—¶é—´è®°å½•ç±»å‹

```typescript
// src/types/index.ts
export interface TimeLog {
  id: string;
  taskId: string;
  userId: string;
  startTime: Date;
  endTime?: Date;
  duration: number; // åˆ†é’Ÿ
  pausedTime: number;
  isActive: boolean;
}

export interface WorkTimeStats {
  dailyTotal: number;
  weeklyTotal: number;
  taskAverageTime: Record<string, number>;
  efficiency: number;
}
```

#### è®¡æ—¶å™¨ç»„ä»¶

```typescript
// src/components/TaskTimer.tsx
import React, { useState, useEffect } from 'react';
import { Box, Button, Typography, Chip } from '@mui/material';
import { PlayArrow, Pause, Stop } from '@mui/icons-material';

interface TaskTimerProps {
  taskId: string;
  onTimeLog: (duration: number) => void;
}

export const TaskTimer: React.FC<TaskTimerProps> = ({ taskId, onTimeLog }) => {
  const [isRunning, setIsRunning] = useState(false);
  const [startTime, setStartTime] = useState<Date | null>(null);
  const [elapsedTime, setElapsedTime] = useState(0);

  useEffect(() => {
    let interval: NodeJS.Timeout;
    if (isRunning && startTime) {
      interval = setInterval(() => {
        setElapsedTime(Math.floor((Date.now() - startTime.getTime()) / 1000));
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [isRunning, startTime]);

  const handleStart = () => {
    setStartTime(new Date());
    setIsRunning(true);
  };

  const handlePause = () => {
    setIsRunning(false);
  };

  const handleStop = () => {
    if (startTime) {
      const duration = Math.floor((Date.now() - startTime.getTime()) / 60000); // åˆ†é’Ÿ
      onTimeLog(duration);
    }
    setIsRunning(false);
    setStartTime(null);
    setElapsedTime(0);
  };

  const formatTime = (seconds: number) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <Box display="flex" alignItems="center" gap={1}>
      <Chip 
        label={formatTime(elapsedTime)}
        color={isRunning ? "primary" : "default"}
        variant={isRunning ? "filled" : "outlined"}
      />
      
      {!isRunning ? (
        <Button 
          startIcon={<PlayArrow />} 
          onClick={handleStart}
          size="small"
        >
          å¼€å§‹è®¡æ—¶
        </Button>
      ) : (
        <>
          <Button 
            startIcon={<Pause />} 
            onClick={handlePause}
            size="small"
          >
            æš‚åœ
          </Button>
          <Button 
            startIcon={<Stop />} 
            onClick={handleStop}
            size="small"
            color="secondary"
          >
            å®Œæˆ
          </Button>
        </>
      )}
    </Box>
  );
};
```

### 5. é€šçŸ¥æœåŠ¡å®ç°

#### é€šçŸ¥æœåŠ¡ç±»

```typescript
// src/services/NotificationService.ts
export class NotificationService {
  private static instance: NotificationService;

  static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  async requestPermission(): Promise<boolean> {
    if (!('Notification' in window)) {
      console.warn('æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥åŠŸèƒ½');
      return false;
    }

    if (Notification.permission === 'granted') {
      return true;
    }

    if (Notification.permission === 'denied') {
      return false;
    }

    const permission = await Notification.requestPermission();
    return permission === 'granted';
  }

  showNotification(title: string, options?: NotificationOptions): void {
    if (Notification.permission === 'granted') {
      new Notification(title, {
        icon: '/favicon.ico',
        badge: '/badge-icon.png',
        ...options
      });
    }
  }

  scheduleTaskReminder(task: Task): void {
    const now = new Date();
    const dueDate = new Date(task.dueDate);
    const reminderTime = new Date(dueDate.getTime() - 60 * 60 * 1000); // æå‰1å°æ—¶

    if (reminderTime > now) {
      const delay = reminderTime.getTime() - now.getTime();
      setTimeout(() => {
        this.showNotification(`ä»»åŠ¡æé†’: ${task.title}`, {
          body: 'ä»»åŠ¡å°†åœ¨1å°æ—¶ååˆ°æœŸï¼Œè¯·åŠæ—¶å¤„ç†',
          tag: `task-reminder-${task.id}`
        });
      }, delay);
    }
  }

  showDailyTaskSummary(tasks: Task[]): void {
    const pendingTasks = tasks.filter(t => t.status !== 'completed');
    this.showNotification('ä»Šæ—¥ä»»åŠ¡æé†’', {
      body: `æ‚¨æœ‰ ${pendingTasks.length} ä¸ªå¾…å®Œæˆä»»åŠ¡`,
      tag: 'daily-summary'
    });
  }
}
```

## é›†æˆåˆ°ç°æœ‰é¡¹ç›®

### ä¿®æ”¹ AppContext

```typescript
// src/context/AppContext.tsx
interface AppState {
  // ç°æœ‰å­—æ®µ...
  timeLogs: TimeLog[];
  comments: TaskComment[];
  notifications: NotificationSettings;
}

interface AppContextType {
  // ç°æœ‰æ–¹æ³•...
  addTimeLog: (timeLog: TimeLog) => void;
  addComment: (comment: TaskComment) => void;
  updateTaskStatus: (taskId: string, status: TaskStatus) => void;
  updateTaskPriority: (taskId: string, priority: TaskPriority) => void;
}
```

### ä¿®æ”¹ mockData

```typescript
// src/utils/mockData.ts
export const mockTasks: Task[] = [
  {
    id: '1',
    title: 'å®Œæˆé¡¹ç›®æ–‡æ¡£',
    description: 'æ•´ç†é¡¹ç›®ç›¸å…³æ–‡æ¡£',
    assignedTo: ['user1'],
    createdBy: 'admin1',
    createdAt: new Date('2024-01-15'),
    dueDate: new Date('2024-01-20'),
    priority: 'high', // æ–°å¢
    priorityColor: '#f44336', // æ–°å¢
    status: 'in_progress', // ä¿®æ”¹
    statusUpdateTime: new Date(),
    statusHistory: []
  },
  // ... å…¶ä»–ä»»åŠ¡
];
```

è¿™äº›ä»£ç å¯ä»¥ç›´æ¥é›†æˆåˆ°æ‚¨ç°æœ‰çš„é¡¹ç›®ä¸­ï¼ŒæŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®ç°ã€‚æ¯ä¸ªåŠŸèƒ½éƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œå¯ä»¥å•ç‹¬å¼€å‘å’Œæµ‹è¯•ã€‚
